import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { fetchCount } from './counterAPI';

/*
Redux 基本概念
1. Reducer
2. State
3. Actions
4. Thunks
5. Slice
6. Selectors
*/

export interface CounterState {
  value: number;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: CounterState = {
  value: 0,
  status: 'idle',
};

/*
The function below is called a thunk and allows us to perform async logic. It
can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
will call the thunk with the `dispatch` function as the first argument. Async
code can then be executed and other actions can be dispatched. Thunks are
typically used to make async requests.
createAsyncThunk 创建一个异步的 action，接收三个参数：typePrefix, payloadCreator, options?: AsyncThunkOptions
*/
export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async (amount: number) => {
    const response = await fetchCount(amount);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const counterSlice = createSlice({
  name: 'counter',

  // 初始状态
  initialState,

  /*
  The `reducers` field lets us define reducers and generate associated actions

  通过 reducers 定义 reducer（含 state 和 action）
  与老版本的 API 不同，老版本要分开定义 state 和 action，新版本都通过 createSlice 统一定义
  在 reducers 定义的 reducer 最终可以通过 createSlice 返回的实例的 actions 属性访问到对应的 Action
  */
  reducers: {
    increment: (state) => {
      /*
      Redux Toolkit allows us to write "mutating" logic in reducers. It
      doesn't actually mutate the state because it uses the Immer library,
      which detects changes to a "draft state" and produces a brand new
      immutable state based off those changes

      Redux Toolkit 允许直接修改 draft state 的逻辑，但因为用到了 Immer 库，是不会真正改变原始的 state
      Immer 会检测到对这个 draft state 的变化，并生成一个全新的不可变的对象替换旧的 state

      为什么需要状态不可变（Immutable）？
      https://juejin.cn/post/7071491157619900447
      */
      state.value += 1;
    },

    // 无 payload 相当于定义了一个类型为 ActionCreatorWithoutPayload 的 Action Creator
    decrement: (state) => {
      state.value -= 1;
    },

    // Use the PayloadAction type to declare the contents of `action.payload`
    // 使用 PayloadAction 类型定义 payload 的类型
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.value += action.payload;
      })
      .addCase(incrementAsync.rejected, (state) => {
        state.status = 'failed';
      });
  },
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

/*
The function below is called a selector and allows us to select a value from the state.
Selectors can also be defined inline where they're used instead of in the slice file.
For example: `useSelector((state: RootState) => state.counter.value)`

下面这个函数是 selector，selector 允许我们从 state 中选择一个值
selectors 可以在它们被使用的地方定义，而不是在 slice 文件中
例如：`useSelector((state: RootState) => state.counter.value)`
*/
export const selectCount = (state: RootState) => state.counter.value;

/*
We can also write thunks by hand, which may contain both sync and async logic.
Here's an example of conditionally dispatching actions based on current state.

我们也可以手动写一些 thunks，这可以包含同步和异步逻辑
这里是一个例子，用来根据当前的 state 来决定是否要 dispatch action
*/
export const incrementIfOdd = (amount: number): AppThunk => {
  return (dispatch, getState) => {
    console.log(2, dispatch);

    const currentValue = selectCount(getState());
    if (currentValue % 2 === 1) {
      dispatch(incrementByAmount(amount));
    }
  };
};

export default counterSlice.reducer;
